
# C Programming: Pass by Pointer (Detailed Notes)

This markdown file explains the concept of "Pass by Pointer" in C, focusing on function parameter behavior, use cases, and best practices. It contrasts pass-by-value vs pass-by-pointer and offers practical coding examples.

---

## üìå Key Concept: Pass by Value vs Pass by Pointer

### ‚ùå Pass by Value (Default in C)
When you pass an argument to a function in C, a copy of that argument is made. Any changes inside the function do not affect the original variable.

#### Example:
```c
[[include]] <stdio.h>

void ConvHrMin(int timeVal, int hrVal, int minVal) {
    hrVal  = timeVal / 60;
    minVal = timeVal % 60;
}

int main(void) {
    int totTime = 156;
    int usrHr = 0;
    int usrMin = 0;

    ConvHrMin(totTime, usrHr, usrMin);

    // This will still print 0 hrs 0 mins
    printf("Equals: %d hrs %d min\n", usrHr, usrMin);

    return 0;
}
```

### üß† Why this fails:
- `usrHr` and `usrMin` are passed **by value**.
- The function creates local copies and modifies **only those copies**.
- The original variables remain unchanged in `main()`.

---

## ‚úÖ Pass by Pointer (Reference)

When a pointer is passed to a function (using `*` and `&`), the function can directly modify the original variable by accessing its memory address.

#### Corrected Example:
```c
[[include]] <stdio.h>

void ConvHrMin (int timeVal, int* hrVal, int* minVal) {
    *hrVal  = timeVal / 60;
    *minVal = timeVal % 60;
}

int main(void) {
    int totTime = 156;
    int usrHr = 0;
    int usrMin = 0;

    ConvHrMin(totTime, &usrHr, &usrMin);

    // Now prints correct values
    printf("Equals: %d hrs %d mins\n", usrHr, usrMin);

    return 0;
}
```

### üß† Why this works:
- `&usrHr` passes the **address** of `usrHr`.
- `*hrVal` dereferences the pointer, allowing modification of `usrHr` directly.

---

## ‚ö†Ô∏è Best Practices and Warnings

### üîí Avoid assigning to pass-by-value parameters
```c
int IntMax(int numVal1, int numVal2) {
    if (numVal1 > numVal2) {
        numVal2 = numVal1; // Misleading and bad style
    }
    return numVal2;
}
```

### üí° Prefer separate functions when outputs are independent
Instead of:
```c
void StepsToFeetAndCalories(int steps, int* feet, int* calories);
```

Do this:
```c
int StepsToFeet(int steps);
int StepsToCalories(int steps);
```

Why?
- More modular
- Can be used in expressions
- Easier to test and reuse

---

## üìò Additional Pointer Function Examples

### CoordTransform
```c
void CoordTransform(int xVal, int yVal, int* xValNew, int* yValNew) {
    *xValNew = (xVal + 1) * 2;
    *yValNew = (yVal + 1) * 2;
}
```

### ConvDigits
```c
void ConvDigits(int inNum, int* tensVal, int* onesVal) {
    *onesVal = inNum % 10;
    *tensVal = inNum / 10;
}
```

Call:
```c
int tensDigit, onesDigit;
ConvDigits(45, &tensDigit, &onesDigit);  // tens = 4, ones = 5
```

---

## üìù Summary

| Type           | Behavior | Modifies Caller Variable? |
|----------------|----------|----------------------------|
| Pass by Value  | Copies value  | ‚ùå No                    |
| Pass by Pointer| Uses address | ‚úÖ Yes                   |

- Use pointers when you need to modify variables from the caller function.
- Use `*` in the function definition and `&` when calling.
- Use sparingly and clearly to avoid confusion.

---

Let me know if you'd like this added to your master notes or converted into flashcards!
